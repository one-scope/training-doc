[戻る](../../../README.md)

# 04-01. エンジニアの心得

社会人エンジニアとして成果をあげるために必要なマインドの獲得を目指します。

- [04-01. エンジニアの心得](#04-01-エンジニアの心得)
  - [社会人基礎力](#社会人基礎力)
  - [エンジニアの技能段階](#エンジニアの技能段階)
  - [プレイヤーとして一人前になるためのステップアップ](#プレイヤーとして一人前になるためのステップアップ)
    - [自分の待遇を決められるのは自分だけ](#自分の待遇を決められるのは自分だけ)
    - [プロのエンジニアの価値基準](#プロのエンジニアの価値基準)
    - [目標のリフレーミング](#目標のリフレーミング)
    - [アサインされるのは”作業”ではなく”責務”](#アサインされるのは作業ではなく責務)
    - [ゴールを明確にし、タスクを洗い出す](#ゴールを明確にしタスクを洗い出す)
    - [言語化できるまで考え抜く](#言語化できるまで考え抜く)
    - [意志決定と説明責任](#意志決定と説明責任)
    - [手を動かす前に仮説を立てる](#手を動かす前に仮説を立てる)
    - [最高効率で勉強・キャッチアップをする](#最高効率で勉強キャッチアップをする)
    - [組織として継続的に勝ち続ける](#組織として継続的に勝ち続ける)

## 社会人基礎力

経済産業省が「社会人基礎力」として、業種・業界問わずすべての社会人が最初に身に付けるべき基礎的スキルを定義しています。  
「社会人基礎力」は次の3つの能力として説明されています。

<img src="images/image.png" width="400px" alt="前に踏み出す力" />

<img src="images/image-1.png" width="400px" alt="考え抜く力" />

<img src="images/image-2.png" width="400px" alt="チームで働く力" />

経済産業省では、これらの「社会人基礎力」をキャリア意識・マインドを持ち続け、  
自己を認識してリフレクション（振り返り）しながら目的、学び、統合のバランスを図ることが、  
自らキャリアを切りひらいていく上で必要としています。

## エンジニアの技能段階

次の表は技能段階を5段階でモデル化したものです。（ドレイファスモデル）

| 段階   | 内容                                                                                                                                                                                                           |
| ------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 上級者 | 問題を探し出し、解決することができる。<br/>根本的な原因を探し出したり、どこに注目して解決するべきかを決定するには苦労する。<br/>プロジェクトの全体は見えているが、技能の全体は見えていない。                   |
| 中級者 | いま起こっている局所的な問題に対処するための情報をいち早く入手したいと考える。<br/>理論や原則を学びたいとは思わない。<br/>全体に対して無関心で、真剣に考える姿勢を見せない。                                   |
| 初心者 | 自分の行動のすべてに関して、それがうまくいくか判断することができない。<br/>学びたい欲求は低く、目の前の目標を達成したいという願望が強い。<br/>状況に左右されない確かなルールが存在する場合は仕事を達成できる。 |
| 熟練者 | 自己改善ができる。<br/>状況を判断できるため、古くからの格言や原則、あるいは他プロジェクトの失敗談から効果的に学ぶことができる。<br/>技能の全体に目を向ける。                                                   |
| 達人   | 膨大な経験を状況に応じて引き出し、応用できる。<br/>常によりよい方法を模索している。<br/>物事を問題について本質的であるかを直感的に判断できる。                                                                 |

一人前のエンジニアとして仕事をするには、少なくとも「上級者」以上の技能段階が必要です。

ドレイファスモデルでは「初心者」から「達人」へと技能段階があがるにごとに、次のように特性が変化します。

- よりどころとする対象が、ルールから直感に移行する
- 認識が、問題を一様な関連性を有する小部分の集合として認識するのではなく、ひとつの完全かつ無類の統一体として認識し、特定の小部分にのみ力を置くようになる
- 問題から遊離して存在する観察者から、システム自身の一部としてそれに関与する存在へと変化する

「達人」になるには、最低10年は努力する覚悟が必要です。  
1年の経験を単にあと9回繰り返しただけでは、経験の積み重ねにはなりません。  
**生半可ではない本気の努力が必要**で、ただ取り組むだけでは不十分です。

## プレイヤーとして一人前になるためのステップアップ

### 自分の待遇を決められるのは自分だけ

自分の待遇を決められるのは誰だと思いますか？  
上司？社長？  
違います。自分です。自分だと思ったほうがいいです。

例えば160時間働いて手取りが10万円だったとして、待っていても評価されたりしません。  
これを会社のせいにしてグチグチ言っていても何も変わらないです。  
この状況を変えれるのは自分だけなんですよ。  
転職するにしても、評価してもらえるようにするにしても、自分で動くしかないんですよ。

お金や評価を得られる環境をつくるだけではなくて、  
自分の働きやすい環境や、自分のやりたいことができる環境をつくるにも、  
やっぱり自分で動くしかないんですよ。  
それが社会人です。

### プロのエンジニアの価値基準

コードを書くのが大好きでエンジニアになる人は多いです。  
そうすると、コードを書いているだけである程度楽しいハズです。悪いことではありません。  
だけど、プロのエンジニアとしてほんとうに大切なのは、仕事として成果を出すことです。  
成果に繋がらないコードを楽しく書き続けていても、それだけではプロのエンジニアとしての価値は低いです。  
仕事として成果を最大化することに楽しさの基準を置くことができると、プロとして強いエンジニアになれます。

仕事とは、成果とはなんだろう。  
動くコードを書く他に、何が成果に繋がるんだろう。  
業務フロー全体に目を向けて、いろいろな観点で考えてみてください。

### 目標のリフレーミング

エンジニアとして市場価値を高めるためには、コーディング以外にも目を向けて、  
できること、任せられること、責任を負えることを増やす必要があります。

次の図はエンジニアの仕事の全体像をざっくりと示したものです。  
（あくまで一例であって、これがすべてではない）  
<img src="images/image-3.png" width="600px" alt="仕事の全体像" />  
「実装」が全体のごく一部でしかないことがわかります。

そして、実装はある程度できて当たり前のことであり、できる人が多いです。  
そんなレッドオーシャンの領域で実装”だけ”で価値を高めることはすごく難しいです。  
実装で100点を取れているところにさらに+10点して110点にしてもあまり価値にならなくて、  
同じ+10点するのなら、できる人が少ない領域、たとえば広報や営業で0点を10点にしたほうが重宝されます。

頼りになる人材になるためには、できることを増やすことです。  
業務フローを理解し、組織の中にどんな仕事があって、何が足りないのか、これをよく観察して  
ステークホルダーにどんどん働きかけ、責任範囲を増やし、自分の価値を高めていく必要があります。  
そうしていく中で、自分のやりたいことができる環境が構築されていきます。

### アサインされるのは”作業”ではなく”責務”

業務上執り行うすべての作業には必ず目的と期限があります。  
目的や期限が無いものは仕事ではありません。

アサインされるのは ”作業を行う” ことではありません。  
アサインされるのは作業の ”期限内に目的を達成し、期待する結果を得るという責務” です。

当たり前ですが、この責務を果たすためには、目的と期限を知らなければいけません。  
同じコーディングという作業でも、目的や期限は毎回違ったものになるでしょう。

例えば、すでにリリースされているものに対する緊急のバグフィックスもあれば、  
勉強のために少し時間をかけてでも丁寧な実装をすることもありえます。  
前者であれば、結果としては多少汚くてもよいので最小最速でバグの流出が止まった状態が期待され、  
後者であれば、結果としては実際に実装した内容よりも人材としての成長が期待されます。  
このような期待される結果を期限内に実現することを担保するのが、責務を果たすということです。

まずは、目的と期限を正しく知ることからはじめましょう。  
目的や期限がわからなかったり曖昧である場合は、必ず確認してください。  
作業を開始したら、ホウレンソウを意識してください。ホウレンソウとは報告・連絡・相談のことです。  
期限内に目的を達成するために、あなたの責任で作業を進め、あなたの責任でホウレンソウを実行します。  
助けを求めるのもあなたの責任です。待っていても誰も助けてくれません。期限内に目的を達成するのはあなたの責務だからです。  
それが、責務を請け負うということです。

### ゴールを明確にし、タスクを洗い出す

解決すべき問題Aがあったとき、これをそのまま「問題Aを解決する」というタスクとして取り組むのはNGです。

- 問題Aはなぜ問題ですか？誰がいつどれくらいの頻度で困っていますか？
- 問題Aはどうして起こっていますか？原因は何ですか？何が課題ですか？
- 問題Aを解決したとき、どういう状態になっているべきですか？
- 問題Aを解決するために最もコスパのよい方法は何ですか？

などなど、考えるべきことは山ほどあります。  
これらを明確にしたうえで、はじめてタスクが洗い出せる状態になります。

タスクは問題を解決する最善の方法から逆算し、いくつかのステップに分割します。  
このとき 5W1H を意識して、具体的な完了条件が明確になるまで詳細化します。  
実際にすべてを言語化する必要はありません。関係者が認識できていればOKです。

### 言語化できるまで考え抜く

ここでいう言語化は、誰かにうまく伝えることではありません。  
自分の考えを明確にすることです。  
「考える」という仕事に対するアウトプットとしての「言語化」です。  
言語化は文章である必要もありません。図や表でも、明確化できればなんでもよいです。脳内にしかなくてもOKです。  
大切なのは、言語化できるまで考え抜くことです。考えるという仕事に対して、きちんとアウトプットをつくることです。

当たり前ですが、どんな仕事でもアウトプットが無ければ、それを評価することはできません。  
アウトプットが無ければ、改善することも、反省することもできません。

考える力を養うにも、アウトプットが必要なんです。  
言語化しなければ、その考えの良し悪しを評価することはできません。  
言語化しなければ、正しく反省し改善することもできません。

アウトプットの無い仕事は、仕事ではありません。  
言語化の無い「考える」は”仕事”ではなく、「悩んでいる」という”状態”です。  
ちゃんと「考え」ましょう。それがすべてのスタートラインです。

### 意志決定と説明責任

業務上のすべての意志決定には説明責任が伴います。

自分が家を建てるとして、工務店さんから「なんとなくこれにしました」「よくわからないけどこうしました」と言われたらどう思いますか？  
ソフトウェアの世界でも同じです。  
コード1行にしたって、そこには意思決定があり、説明責任があります。

これは対お客さんへの説明責任だけでなく、チーム開発をする上でも必要なことです。  
我々がコードを読むとき、すべてのコードには理由があることを大前提として、その意図を汲み取ろうとします。  
意図のない無責任なコードは、コードを読む作業に著しい負荷を与えます。  
議論するにも、意図がなければできません。

コードを例に出しましたが、機能設計やワークフローの設計などでも同じです。  
繰り返しになりますが、業務上のすべての意志決定には説明責任が伴います。  
ちゃんと説明できるように、よく考え、責任をもって意志決定を行いましょう。

### 手を動かす前に仮説を立てる

手が速い人はなぜ手が速いのでしょうか。  
タイピングが速い？エディタの使いかたをよく知っている？IT知識がある？  
違います。

手が速い人は、手戻りが無いのです。  
どうして手戻りなく作業できるのか。  
それは、手を動かす前に何パターンも仮説を立てて確信を得てから手を動かすからです。

逆に、手が遅い人はすぐに手を動かしはじめます。  
すぐにコードを書き換え、試行錯誤します。  
そうして、偶然うまくいった（ように見えるもの）を”完成”として PR を出します。  

これには大きく2つ問題があります。  
まず、どうしても試行錯誤の痕跡が残りやすいこと。  
プリントデバッグや、条件分岐を常に true にするようなコードを消し忘れ、”完成”したものに混じってしまいます。  
次に、アプリやサービス全体として見たときの整合性が崩れやすいこと。  
試行錯誤して偶然うまくいっただけなので、アプリやサービス全体としてどうあるべきかが考慮されません。どうしても歪になります。

この2つの問題は当然 PR などで指摘され、また試行錯誤がはじまります。  
偶然ほんとうにうまくいくまで試行錯誤を繰り返すことになります。  
これでは終わりは見えません。このやり方では見積もりやスケジュールを立てることも不可能でしょう。  
また、PR などで指摘されなかった場合、これらは負債として残り続けます。  
プロジェクトの生産性はどんどん下がっていき、より大きな地獄が待っています。  

こうならないために、手を動かす前に仮説を立て、  
最小の労力でアプリやサービス全体として整合性を保ちつつ最大の成果を出すための方法を考えるのです。  
それは、コード設計かもしれないし、機能の仕様かもしれないし、ステークホルダーとの要件の調整かもしれません。

※ 手が速い人はこうした仮説検証の過程で手が遅い人よりも考える回数（＝経験値）が圧倒的に多いです。  
　 この圧倒的な経験値の差が "伸びる人" と "伸びない人" の差です。

### 最高効率で勉強・キャッチアップをする

できることをやってもしかたがないので、できないことをやりましょう。  
じゃあ、業務上の価値に繋がるもので、自分のできないことってなんだろう？考えてみてください。

これを考えるには、業務フローが見えていないといけません。  
視点を変えて見てみましょう。  
まわりの人や目の前のコードではなく、業務全体を俯瞰する視点です。

そして、想像してください。  
今後、どのような業務が発生するか。  
業務フローの中でウィークポイント（組織としてフォローできていない要素、弱い要素）はどこか。

ウィークポイントが想像できたら、その中から習得するものをピックアップします。  
このときピックアップするべきなのは「習得しやすいもの」、もしくは「面倒くさいもの」です。  
「習得しやすいもの」は比較的簡単に価値をつくれるのでコスパがいいです。  
「面倒くさいもの」は誰もやりたがらないので価値が高く、かつ面倒なことはやればできるので習得も容易でコスパが高いです。

また、ウィークポイントは常に頭に置いておきましょう。  
情報収集など何かをインプットするときは、ウィークポイントに対してどう効くのかを基準に情報の価値を評価してください。  
そうすることで、次に何かを習得しようとするとき、頭の中にすでに地図ができている状態にできます。  
これまで難しいと思っていたものが、いつのまにか「習得しやすいもの」や「面倒くさいもの」になっていることもあります。

具体的な勉強方法としては、学びの段階を意識したアウトプット中心の勉強が必要です。  
学びの段階：知っている → 理解している → 実行できる → 教えられる

- ただ知るだけでなく、それがどのウィークポイントに対してどのように働くのかを理解する
- ただ理解するだけでなく、それを実行してウィークポイントを解決できる状態にする
- ただ実行できるだけでなく、それを言語化（もしくはライブラリ化）して組織としてウィークポイントを解決できる状態にする

知るより理解、理解より実行、実行より言語化、  
インプットよりもアウトプットを重視することでより効率よく深く勉強することができます。  
※ 手っ取り早い勉強方法は、そのトピックを教えるセミナーを自ら主催することです

常日頃からこのように考え行動していくことが、  
最高効率で自分の価値を高める勉強・キャッチアップの方法です。

### 組織として継続的に勝ち続ける

組織に属するプロのエンジニアは、お金をつかってお金を生むためのコードを書きます。  
どれだけ正しいコードを書いたとしても、使ってもらえなければ意味がないです。  
アプリやサービスを使う実際のユーザーや、発注してくれたお客様に対してどのような価値を届けるのか、  
競合他社よりも自社のアプリやサービスのほうが価値が高いと自信をもって言えなければいけないです。

価値を届けるときの一般的な考え方として、QCD = Quality（品質）、Cost（コスト）、Delivery（納期）があります。  
QCD は案件ごとのスコープで考えてしまいがちですが、組織としていかに継続的に QCD を満たし続けられるか、いかにその仕組みをつくれるかが重要です。  
継続的に QCD を満たし続けられる仕組みがあって、はじめてプロのエンジニア組織として市場での戦いに参加できる状態になります。

バグのないコードを書くのは当然で、仕事をしながらいかに組織としての資産をつくれるかが重要です。  
例：保守しやすい資産としてのコード、ノウハウの蓄積、ライブラリ化、ワークフロー化、など
